package com.in28minutes.jpa.hibernate.demo.repository;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.List;

import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

import com.in28minutes.jpa.hibernate.demo.entity.Course;
import com.in28minutes.jpa.hibernate.demo.entity.Passport;
import com.in28minutes.jpa.hibernate.demo.entity.Student;

@SpringBootTest
class StudentRepositoryTest {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @Autowired
    StudentRepository studentRepo;

    // To run this test, and see only 1 SQL firing, make sure that the Passport in
    // Student is of EAGER FetchType
    @Disabled
    @Test
    void findStudentWithPassportRelationshipIsEagerFetch() {
	// Because the student/passport relationship is OneToOne, the passport details
	// are fetched automatically whenever the student is retrieved. This is called
	// EAGER fetching.

	// This will result in an SQL that retrieves both the Student & Passport
	// details, because Passport is marked as EAGER
	Student s = studentRepo.findById(20001L);

	// No Session error will be thrown here if Passport is set to LAZY, because this
	// method is not annotated with @Transactional, so the transaction ends
	// immediately after studentRepo.findById has completed
	assertEquals("A1234567", s.getPassport().getNumber());
    }

    // To run this test, and see the 2 SQLs firing, make sure that the Passport in
    // Student is of LAZY FetchType
    @Test
    @Transactional // This puts this method in 1 transaction (which allows the passport to be
		   // retrieved using an extra SQL)
    void findStudentWithPassportRelationshipIsLazyFetch() {
	// This will result in an SQL that just retrieves the Student info
	Student s = studentRepo.findById(20001L);

	// This will result in another SQL firing to retrieve the Passport info
	Passport p = s.getPassport();

	assertEquals("A1234567", p.getNumber());
    }

    @Test
    @Transactional
    void playWithGettingAStudentAndTheirCourses() {
	Student s = studentRepo.findById(20002L);

	List<Course> courses = s.getCourses();

	logger.info("\n\n\nStudent {} Courses: {}\n\n\n", s.getId(), courses);

	assertEquals(courses.size(), 3);
//	assertEquals("History", courses.get(0).getName());
//	assertEquals("ReactJS", courses.get(1).getName());
//	assertEquals("English", courses.get(2).getName());

	for (Course course : courses) {
	    assertTrue(course.getName().equals("History") || course.getName().equals("ReactJS")
		    || course.getName().equals("English"));
	}
    }

//    @Test
//    @Transactional
//    void testIdGeneration() {
//	Student s1 = new Student("Temp Student 1");
//	studentRepo.save(s1);
//
//	logger.info("Student 1's Id: {}", s1.getId());
//	logger.info("Number of Students: {}", studentRepo.getCount());
//
//	// This will roll back the transaction, but the ID generated by the DB doesn't
//	// get rolled back
//	throw new RuntimeException("Seeing if the ID generated will be rolled back");
//    }
//
//    @Test
//    @Transactional
//    void testIdGeneration2() {
//	Student s1 = new Student("Temp Student 2");
//	studentRepo.save(s1);
//
//	logger.info("Student 2's Id: {}", s1.getId());
//	logger.info("Number of Students: {}", studentRepo.getCount());
//
//	// This will roll back the transaction, but the ID generated by the DB doesn't
//	// get rolled back
//	throw new RuntimeException("Seeing if the ID generated will be rolled back");
//    }
}